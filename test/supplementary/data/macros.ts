import type { SupplementaryTest } from "../types.js";

const C = "macros";

export const macroTests: SupplementaryTest[] = [
  // === has() macro ===
  {
    name: "has existing property",
    expr: "has(object.property)",
    expected: true,
    bindings: { object: { property: true } },
    category: C,
  },
  {
    name: "has missing property",
    expr: "has(object.nonExisting)",
    expected: false,
    bindings: { object: { property: true } },
    category: C,
  },
  {
    name: "has nested existing",
    expr: "has(user.profile.name)",
    expected: true,
    bindings: { user: { profile: { name: "John" } } },
    category: C,
  },
  {
    name: "has nested missing",
    expr: "has(user.profile.age)",
    expected: false,
    bindings: { user: { profile: { name: "John" } } },
    category: C,
  },
  {
    name: "has deep nested",
    expr: "has(user.profile.foo.bar)",
    expected: true,
    bindings: { user: { profile: { foo: { bar: "hello" } } } },
    category: C,
  },
  {
    name: "has in guard condition",
    expr: "has(object.nonExisting) && object.nonExisting",
    expected: false,
    bindings: { object: { property: true } },
    category: C,
  },
  {
    name: "has mid-path missing throws",
    expr: "has(user.nonExisting.foo)",
    expectError: true,
    bindings: { user: { profile: { name: "John" } } },
    category: C,
  },
  { name: "has() no args", expr: "has()", expectError: true, category: C },
  {
    name: "has() two args",
    expr: "has(a, b)",
    expectError: true,
    bindings: { a: 1, b: 2 },
    category: C,
  },
  {
    name: "has() on identifier",
    expr: "has(object)",
    expectError: true,
    bindings: { object: { property: true } },
    category: C,
  },
  { name: "has() on string literal", expr: 'has("")', expectError: true, category: C },
  { name: "has() on array literal", expr: "has([])", expectError: true, category: C },
  { name: "has() on bool literal", expr: "has(true)", expectError: true, category: C },
  { name: "has() on number literal", expr: "has(42)", expectError: true, category: C },
  {
    name: "has() on bracket access",
    expr: 'has(user["profile"])',
    expectError: true,
    bindings: { user: { profile: { name: "John" } } },
    category: C,
  },
  { name: "has() unknown var", expr: "has(nonexistent.foo)", expectError: true, category: C },

  // === all() macro ===
  {
    name: "all true",
    expr: "numbers.all(x, x > 0)",
    expected: true,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "all false",
    expr: "numbers.all(x, x > 3)",
    expected: false,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "all empty list",
    expr: "emptyList.all(x, x > 0)",
    expected: true,
    bindings: { emptyList: [] },
    category: C,
  },
  {
    name: "all with string ops",
    expr: "strings.all(s, s.size() > 3)",
    expected: true,
    bindings: { strings: ["hello", "world", "test"] },
    category: C,
  },
  {
    name: "all with string ops false",
    expr: "strings.all(s, s.size() > 5)",
    expected: false,
    bindings: { strings: ["hello", "world", "test"] },
    category: C,
  },
  {
    name: "all complex predicate",
    expr: "users.all(u, u.age >= 25 && u.name.size() > 2)",
    expected: true,
    bindings: {
      users: [
        { name: "Alice", age: 25 },
        { name: "Bob", age: 30 },
        { name: "Charlie", age: 35 },
      ],
    },
    category: C,
  },
  {
    name: "all no args error",
    expr: "numbers.all()",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "all one arg error",
    expr: "numbers.all(x)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  { name: "all on non-list", expr: "42.all(x, x > 0)", expectError: true, category: C },
  { name: "all on string", expr: '"hello".all(x, x > 0)', expectError: true, category: C },
  {
    name: "all non-receiver call",
    expr: "all(numbers, x, x > 4)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "all must return bool",
    expr: "numbers.all(x, x)",
    expectError: true,
    bindings: { numbers: [1, 2, 3] },
    category: C,
  },

  // === exists() macro ===
  {
    name: "exists true",
    expr: "numbers.exists(x, x > 4)",
    expected: true,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "exists false",
    expr: "numbers.exists(x, x > 10)",
    expected: false,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "exists empty list",
    expr: "emptyList.exists(x, x > 0)",
    expected: false,
    bindings: { emptyList: [] },
    category: C,
  },
  {
    name: "exists with startsWith",
    expr: 'strings.exists(s, s.startsWith("h"))',
    expected: true,
    bindings: { strings: ["hello", "world", "test"] },
    category: C,
  },
  {
    name: "exists with startsWith false",
    expr: 'strings.exists(s, s.startsWith("z"))',
    expected: false,
    bindings: { strings: ["hello", "world", "test"] },
    category: C,
  },
  {
    name: "exists must return bool",
    expr: "numbers.exists(x, x)",
    expectError: true,
    bindings: { numbers: [1, 2, 3] },
    category: C,
  },
  {
    name: "exists no args error",
    expr: "numbers.exists()",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "exists non-receiver call",
    expr: "exists(numbers, x, x > 4)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },

  // === exists_one() macro ===
  {
    name: "exists_one true",
    expr: "numbers.exists_one(x, x == 3)",
    expected: true,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "exists_one none match",
    expr: "numbers.exists_one(x, x > 10)",
    expected: false,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "exists_one multiple match",
    expr: "numbers.exists_one(x, x > 2)",
    expected: false,
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "exists_one empty list",
    expr: "emptyList.exists_one(x, x > 0)",
    expected: false,
    bindings: { emptyList: [] },
    category: C,
  },
  {
    name: "exists_one must return bool",
    expr: "numbers.exists_one(x, x)",
    expectError: true,
    bindings: { numbers: [1, 2, 3] },
    category: C,
  },
  {
    name: "exists_one no args error",
    expr: "numbers.exists_one()",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "exists_one non-receiver call",
    expr: "exists_one(numbers, x, x > 4)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },

  // === map() macro ===
  {
    name: "map transform",
    expr: "numbers.map(x, x * 2.0)",
    expected: [2, 4, 6, 8, 10],
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "map extract names",
    expr: "users.map(u, u.name)",
    expected: ["Alice", "Bob"],
    bindings: {
      users: [
        { name: "Alice", age: 25 },
        { name: "Bob", age: 30 },
      ],
    },
    category: C,
  },
  {
    name: "map string sizes",
    expr: "strings.map(s, s.size())",
    expected: [5n, 5n],
    bindings: { strings: ["hello", "world"] },
    category: C,
  },
  {
    name: "map empty list",
    expr: "emptyList.map(x, x * 2.0)",
    expected: [],
    bindings: { emptyList: [] },
    category: C,
  },
  {
    name: "map 3-arg filter form",
    expr: "numbers.map(x, x > 2, x * 2.0)",
    expected: [6, 8, 10],
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "map 3-arg filter all true",
    expr: "numbers.map(x, true, x + 1.0)",
    expected: [2, 3, 4, 5, 6],
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "map 3-arg filter all false",
    expr: "numbers.map(x, false, x + 1.0)",
    expected: [],
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "map on object keys",
    expr: "object.map(x, x)",
    expected: ["key1", "key2"],
    bindings: { object: { key1: "value1", key2: "value2" } },
    category: C,
  },
  {
    name: "map no args error",
    expr: "numbers.map()",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "map one arg error",
    expr: "numbers.map(x)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "map non-receiver call",
    expr: "map(numbers, x, x > 4)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "map filter must be bool",
    expr: "numbers.map(x, x, x)",
    expectError: true,
    bindings: { numbers: [1, 2, 3] },
    category: C,
  },

  // === filter() macro ===
  {
    name: "filter all true",
    expr: "numbers.filter(x, true)",
    expected: [0, 1, 2, 3, 4, 5],
    bindings: { numbers: [0, 1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "filter all false",
    expr: "numbers.filter(x, false)",
    expected: [],
    bindings: { numbers: [0, 1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "filter gt 3",
    expr: "numbers.filter(x, x > 3)",
    expected: [4, 5],
    bindings: { numbers: [0, 1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "filter strings by size",
    expr: "strings.filter(s, s.size() > 4)",
    expected: ["hello", "world", "example"],
    bindings: { strings: ["hello", "world", "test", "example"] },
    category: C,
  },
  {
    name: "filter strings startsWith",
    expr: 'strings.filter(s, s.startsWith("t"))',
    expected: ["test"],
    bindings: { strings: ["hello", "world", "test", "example"] },
    category: C,
  },
  {
    name: "filter empty list",
    expr: "emptyList.filter(x, x > 0)",
    expected: [],
    bindings: { emptyList: [] },
    category: C,
  },
  {
    name: "filter no matches",
    expr: "numbers.filter(x, x > 20)",
    expected: [],
    bindings: { numbers: [0, 1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "filter map keys",
    expr: 'object.filter(x, x.startsWith("key"))',
    expected: ["key1", "key2"],
    bindings: { object: { key1: "value1", key2: "value2" } },
    category: C,
  },
  {
    name: "filter must return bool",
    expr: "numbers.filter(x, x)",
    expectError: true,
    bindings: { numbers: [1, 2, 3] },
    category: C,
  },
  {
    name: "filter no args error",
    expr: "numbers.filter()",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },
  {
    name: "filter non-receiver call",
    expr: "filter(numbers, x, x > 4)",
    expectError: true,
    bindings: { numbers: [1] },
    category: C,
  },

  // === cel.bind() macro ===
  { name: "cel.bind int", expr: "cel.bind(x, 10, x * 2)", expected: 20n, category: C },
  {
    name: "cel.bind string",
    expr: 'cel.bind(name, "World", "Hello, " + name + "!")',
    expected: "Hello, World!",
    category: C,
  },

  // === Macro chaining ===
  {
    name: "filter then map",
    expr: "numbers.filter(x, int(x) % 2 == 0).map(x, int(x) * 2)",
    expected: [4n, 8n],
    bindings: { numbers: [1, 2, 3, 4, 5] },
    category: C,
  },
  {
    name: "filter then all",
    expr: "users.filter(u, u.age > 30).all(u, u.name.size() > 3)",
    expected: true,
    bindings: {
      users: [
        { name: "Alice", age: 25 },
        { name: "Bob", age: 30 },
        { name: "Charlie", age: 35 },
      ],
    },
    category: C,
  },

  // === Macro error handling ===
  {
    name: "all invalid var in predicate",
    expr: "[1, 2, 3].all(x, nonexistent > 0)",
    expectError: true,
    category: C,
  },
  {
    name: "filter type error in predicate",
    expr: '[1, 2].filter(s, s.startsWith("w"))',
    expectError: true,
    category: C,
  },

  // === Quantifier error absorption ===
  {
    name: "exists swallows errors on match",
    expr: "items.exists(i, i.foo == 'bar')",
    expected: true,
    bindings: { items: [false, 1, false, { foo: "bar" }] },
    category: C,
  },
  {
    name: "all swallows errors on false",
    expr: "items.all(i, i == true)",
    expected: false,
    bindings: { items: [false, 1, false, { foo: "bar" }] },
    category: C,
  },
  {
    name: "exists throws when none match",
    expr: "items.exists(i, i.bar == 'bar')",
    expectError: true,
    bindings: { items: [false, 1, false, { foo: "bar" }] },
    category: C,
  },
  {
    name: "all throws when none match",
    expr: "items.all(i, i.bar == true)",
    expectError: true,
    bindings: { items: [false, 1, false, { foo: "bar" }] },
    category: C,
  },

  // === Map macro iteration on maps ===
  {
    name: "all on map keys",
    expr: "scores.all(s, scores[s] > 70)",
    expected: true,
    bindings: { scores: { alice: 85, bob: 90, charlie: 75 } },
    category: C,
  },
  {
    name: "exists on map keys",
    expr: "scores.exists(s, scores[s] > 85)",
    expected: true,
    bindings: { scores: { alice: 85, bob: 90, charlie: 75 } },
    category: C,
  },
  {
    name: "filter on map keys",
    expr: "scores.filter(s, scores[s] > 80)",
    expected: ["alice", "bob"],
    bindings: { scores: { alice: 85, bob: 90, charlie: 75 } },
    category: C,
  },
];
