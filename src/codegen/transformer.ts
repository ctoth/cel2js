// CEL AST -> ESTree AST transformer.
// Walks the CelExpr discriminated union and produces ESTree nodes.

import type { Expression, Program, Statement } from "estree";
import type { CelExpr } from "../parser/ast.js";
import {
  arrayExpr,
  arrowFn,
  assignExpr,
  bigintLiteral,
  binaryExpr,
  blockStatement,
  callExpr,
  conditional,
  dot,
  exprStatement,
  identifier,
  literal,
  logicalExpr,
  memberExpr,
  newExpr,
  program,
  returnStatement,
  rtCall,
  sequenceExpr,
  unaryExpr,
  varDecl,
} from "./estree-builders.js";

// ---------------------------------------------------------------------------
// Temp variable allocator for logical AND/OR error absorption
// ---------------------------------------------------------------------------

class TempAllocator {
  private counter = 0;
  private readonly used: string[] = [];

  next(): string {
    const n = this.counter;
    // _$a.._$z, then _$aa, _$ab, ... for overflow
    let name: string;
    if (n < 26) {
      name = `_$${String.fromCharCode(97 + n)}`;
    } else {
      // Multi-char: _$aa, _$ab, ..., _$az, _$ba, ...
      const hi = Math.floor(n / 26) - 1;
      const lo = n % 26;
      name =
        (hi < 26 ? `_$${String.fromCharCode(97 + hi)}` : `_$${hi.toString(36)}`) +
        String.fromCharCode(97 + lo);
    }
    this.counter++;
    this.used.push(name);
    return name;
  }

  getUsed(): readonly string[] {
    return this.used;
  }
}

export interface QualifiedBinding {
  /** Qualified path segments resolved once in evaluate() */
  segments: readonly string[];
}

class QualifiedBindingAllocator {
  private readonly byPath = new Map<string, QualifiedBinding>();

  registerValue(segments: readonly string[]): void {
    const key = segments.join(".");
    if (!this.byPath.has(key)) {
      this.byPath.set(key, { segments: [...segments] });
    }
  }

  getUsed(): readonly QualifiedBinding[] {
    return [...this.byPath.values()];
  }
}

let activeQualifiedBindings: QualifiedBindingAllocator | undefined;
let activeLocalBindings = new Set<string>();

// ---------------------------------------------------------------------------
// Transformer
// ---------------------------------------------------------------------------

export interface TransformResult {
  /** The ESTree program wrapping the expression in an arrow function */
  program: Program;
  /** The generated temp variable names that need `let` declarations */
  temps: readonly string[];
  /** Binding variable names discovered during transformation */
  bindings: readonly string[];
  /** Qualified value paths surfaced to evaluate() for qb cache prepopulation */
  qualifiedBindings: readonly QualifiedBinding[];
}

/**
 * Transform a CEL AST into a complete ESTree Program.
 *
 * The generated program has the shape:
 * ```
 * (_rt, binding1, binding2, ...) => {
 *   let _a, _b, ...;
 *   return <expr>;
 * }
 * ```
 */
export function transform(celAst: CelExpr): TransformResult {
  const temps = new TempAllocator();
  const bindingSet = new Set<string>();
  const qualifiedBindingSet = new QualifiedBindingAllocator();
  let expr!: Expression;
  const previousLocalBindings = activeLocalBindings;
  activeQualifiedBindings = qualifiedBindingSet;
  activeLocalBindings = new Set();
  try {
    expr = transformExpr(celAst, temps, bindingSet);
  } finally {
    activeQualifiedBindings = undefined;
    activeLocalBindings = previousLocalBindings;
  }

  const usedTemps = temps.getUsed();
  const body: Statement[] = [];

  // Declare temp variables if any were used
  for (const tmp of usedTemps) {
    body.push(varDecl("let", tmp, identifier("undefined")));
  }

  body.push(returnStatement(expr));

  const bindings = [...bindingSet];
  const qualifiedBindings = qualifiedBindingSet.getUsed();

  const prog = program([
    exprStatement(
      arrowFn(
        [identifier("_rt"), identifier("_qb"), ...bindings.map((b) => identifier(b))],
        blockStatement(body),
        false, // block body, not expression
      ),
    ),
  ]);

  return { program: prog, temps: usedTemps, bindings, qualifiedBindings };
}

// ---------------------------------------------------------------------------
// Core recursive transform
// ---------------------------------------------------------------------------

const UNDEF = identifier("undefined");

/** CEL type constant names — these resolve to CelType values, not bindings. */
const CEL_TYPE_CONSTANTS = new Set([
  "bool",
  "int",
  "uint",
  "double",
  "string",
  "bytes",
  "list",
  "map",
  "type",
  "null_type",
  "optional_type",
]);

/** Pattern for synthetic names generated by the parser for cel.block/cel.iterVar.
 *  _bi0, _bi1, ... → block index variables; _iv_0_0, _iv_1_0, ... → iteration variables. */
const SYNTHETIC_NAME_RE = /^_bi\d+$|^_iv_\d+_\d+$/;

/** Check if a name is a synthetic identifier generated by the parser. */
function isSyntheticName(name: string): boolean {
  return SYNTHETIC_NAME_RE.test(name);
}

/** Safe array index — asserts element exists (length already validated by caller). */
function at<T>(arr: readonly T[], i: number): T {
  const v = arr[i];
  if (v === undefined) throw new Error(`Expected element at index ${i}`);
  return v;
}

function withLocalBindings<T>(names: readonly string[], fn: () => T): T {
  const previous = activeLocalBindings;
  activeLocalBindings = new Set(previous);
  for (const name of names) {
    activeLocalBindings.add(name);
  }
  try {
    return fn();
  } finally {
    activeLocalBindings = previous;
  }
}

/**
 * Collect a chain of Select nodes from an Ident root.
 * For `Select(Select(Ident("a"), "b"), "c")` returns `["a", "b", "c"]`.
 * Returns undefined if the chain does not bottom out at an Ident.
 */
function collectSelectChain(node: CelExpr): string[] | undefined {
  if (node.kind === "Ident") return [node.name];
  if (node.kind === "Select" && !node.testOnly) {
    const parent = collectSelectChain(node.operand);
    if (parent !== undefined) return [...parent, node.field];
  }
  return undefined;
}

/** Build an ESTree expression for qualified value lookup and register its full path. */
function buildQualifiedResolution(
  segments: string[],
  _temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  const rootName = segments[0] as string;
  if (activeLocalBindings.has(rootName)) {
    return applySelectChain(identifier(rootName), segments.slice(1));
  }
  if (activeQualifiedBindings === undefined) {
    throw new Error("Qualified binding allocator is not initialized");
  }
  activeQualifiedBindings.registerValue(segments);

  const _b = identifier("_qb");
  bindings.add(rootName);

  const fallback: Expression = applySelectChain(identifier(rootName), segments.slice(1));
  let result: Expression = fallback;

  for (let i = 1; i < segments.length; i++) {
    const key = segments.slice(0, i + 1).join(".");
    const lookupExpr: Expression = memberExpr(_b, literal(key), true);
    const selected = applySelectChain(lookupExpr, segments.slice(i + 1));
    result = conditional(binaryExpr("in", literal(key), _b), selected, result);
  }

  return result;
}

/**
 * Build an ESTree expression for qualified has() resolution.
 * Like buildQualifiedResolution but for has() on qualified paths.
 *
 * For segments ["a", "b", "c"] with testOnly (has), generates:
 *   "a.b.c" in _b ? true :
 *   "a.b" in _b ? _rt.has(_b["a.b"], "c") :
 *   _rt.has(_rt.select(a, "b"), "c")
 */
function buildQualifiedHas(
  segments: string[],
  field: string,
  _temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  const _b = identifier("_qb");
  const fullPath = [...segments, field];

  // Fallback: root as simple binding, then selects, then has
  const rootName = segments[0] as string;
  if (!isSyntheticName(rootName)) {
    bindings.add(rootName);
  }

  let fallbackBase: Expression = identifier(rootName);
  for (let i = 1; i < segments.length; i++) {
    fallbackBase = rtCall("select", [fallbackBase, literal(segments[i] as string)]);
  }
  const fallback: Expression = rtCall("has", [fallbackBase, literal(field)]);

  // Build from intermediate prefixes (skip root — redundant with fallback)
  // to longest (full path). Longest ends up outermost (checked first).
  let result: Expression = fallback;
  for (let i = 1; i < fullPath.length; i++) {
    const key = fullPath.slice(0, i + 1).join(".");
    const remaining = fullPath.slice(i + 1);

    if (remaining.length === 0) {
      // Entire path is in _qb -> has = true
      result = conditional(binaryExpr("in", literal(key), _b), literal(true), result);
    } else {
      // Partial path in _qb, remaining fields need has/select
      const lookupExpr: Expression = memberExpr(_b, literal(key), true);
      let base: Expression = lookupExpr;
      for (let j = 0; j < remaining.length - 1; j++) {
        base = rtCall("select", [base, literal(remaining[j] as string)]);
      }
      const hasExpr = rtCall("has", [base, literal(remaining[remaining.length - 1] as string)]);
      result = conditional(binaryExpr("in", literal(key), _b), hasExpr, result);
    }
  }

  return result;
}

/**
 * Operator function name -> _rt method name.
 * These match the property names on the object returned by createRuntime().
 */
const OPERATOR_TO_RT: Record<string, string> = {
  "_+_": "add",
  "_-_": "sub",
  "_*_": "mul",
  "_/_": "div",
  "_%_": "mod",
  "-_": "neg",
  "_<_": "lt",
  "_<=_": "le",
  "_>_": "gt",
  "_>=_": "ge",
  "_==_": "eq",
  "_!=_": "ne",
  "_[_]": "index",
  "_?._": "optionalSelect",
  "_[?_]": "optionalIndex",
  "@in": "in",
};

/** Known global functions -> _rt method names */
const GLOBAL_FUNC_TO_RT: Record<string, string> = {
  size: "size",
  contains: "contains",
  startsWith: "startsWith",
  endsWith: "endsWith",
  matches: "matches",
  int: "toInt",
  uint: "toUint",
  double: "toDouble",
  string: "toString",
  bool: "toBool",
  bytes: "toBytes",
  type: "type",
  duration: "duration",
  timestamp: "timestamp",
  dyn: "dyn",
  // Network extension globals
  ip: "ip",
  cidr: "cidr",
  isIP: "isIP",
};

/** Known extension namespaces — calls like math.fn() route to _rt["math.fn"]() */
const NAMESPACE_PREFIXES = new Set(["math", "base64", "optional", "proto", "ip"]);

/** Optional member methods — these get special routing to optionalXxx runtime methods */
const OPTIONAL_MEMBER_METHODS = new Set([
  "hasValue",
  "value",
  "or",
  "orValue",
  "optMap",
  "optFlatMap",
]);

/** Optional member methods -> _rt method names */
const OPTIONAL_MEMBER_TO_RT: Record<string, string> = {
  hasValue: "optionalHasValue",
  value: "optionalValue",
  or: "optionalOr",
  orValue: "optionalOrValue",
};

/** Known member functions -> _rt method names (receiver becomes first arg) */
const MEMBER_FUNC_TO_RT: Record<string, string> = {
  contains: "contains",
  startsWith: "startsWith",
  endsWith: "endsWith",
  matches: "matches",
  size: "size",
  // String extensions
  charAt: "charAt",
  indexOf: "indexOf",
  lastIndexOf: "lastIndexOf",
  lowerAscii: "lowerAscii",
  upperAscii: "upperAscii",
  replace: "replace",
  split: "split",
  substring: "substring",
  trim: "trim",
  join: "join",
  quote: "quote",
  format: "format",
  // Timestamp/Duration accessors
  getFullYear: "getFullYear",
  getMonth: "getMonth",
  getDate: "getDate",
  getDayOfMonth: "getDayOfMonth",
  getDayOfWeek: "getDayOfWeek",
  getDayOfYear: "getDayOfYear",
  getHours: "getHours",
  getMinutes: "getMinutes",
  getSeconds: "getSeconds",
  getMilliseconds: "getMilliseconds",
  // Network extension
  ip: "ip",
  family: "family",
  isUnspecified: "isUnspecified",
  isLoopback: "isLoopback",
  isGlobalUnicast: "isGlobalUnicast",
  isLinkLocalMulticast: "isLinkLocalMulticast",
  isLinkLocalUnicast: "isLinkLocalUnicast",
  containsIP: "containsIP",
  containsCIDR: "containsCIDR",
  masked: "masked",
  prefixLength: "prefixLength",
};

function transformExpr(node: CelExpr, temps: TempAllocator, bindings: Set<string>): Expression {
  switch (node.kind) {
    // -- Literals -------------------------------------------------------

    case "IntLiteral":
      return bigintLiteral(node.value);

    case "UintLiteral":
      return rtCall("celUint", [bigintLiteral(node.value)]);

    case "DoubleLiteral":
      return literal(node.value);

    case "StringLiteral":
      return literal(node.value);

    case "BoolLiteral":
      return literal(node.value);

    case "NullLiteral":
      return literal(null);

    case "BytesLiteral":
      return newExpr(identifier("Uint8Array"), [arrayExpr([...node.value].map((b) => literal(b)))]);

    // -- Ident ----------------------------------------------------------

    case "Ident":
      // CEL type constants resolve to CelType values, not bindings
      if (CEL_TYPE_CONSTANTS.has(node.name)) {
        return newExpr(memberExpr(identifier("_rt"), identifier("CelType")), [literal(node.name)]);
      }
      // Synthetic identifiers from cel.block/cel.iterVar are local, not external bindings
      if (!isSyntheticName(node.name)) {
        bindings.add(node.name);
      }
      return identifier(node.name);

    // -- Select ---------------------------------------------------------

    case "Select": {
      // Check for qualified identifier chain: a.b.c -> Select(Select(Ident("a"), "b"), "c")
      const chain = collectSelectChain(node);
      if (chain !== undefined && chain.length > 1 && !isSyntheticName(chain[0] as string)) {
        if (node.testOnly) {
          // has() on a qualified chain
          const parentChain = chain.slice(0, -1);
          return buildQualifiedHas(parentChain, chain[chain.length - 1] as string, temps, bindings);
        }
        return buildQualifiedResolution(chain, temps, bindings);
      }

      if (node.testOnly) {
        // has() macro: check if field is defined
        const operand = transformExpr(node.operand, temps, bindings);
        return rtCall("has", [operand, literal(node.field)]);
      }
      const operand = transformExpr(node.operand, temps, bindings);
      return rtCall("select", [operand, literal(node.field)]);
    }

    // -- Call -----------------------------------------------------------

    case "Call":
      return transformCall(node.fn, node.target, node.args, temps, bindings);

    // -- CreateList -----------------------------------------------------

    case "CreateList": {
      const hasOptional = node.optionalIndices !== undefined && node.optionalIndices.length > 0;
      if (hasOptional) {
        return rtCall("makeListOptional", [
          arrayExpr(node.elements.map((e) => transformExpr(e, temps, bindings))),
          arrayExpr((node.optionalIndices ?? []).map((i) => literal(i))),
        ]);
      }
      return rtCall("makeList", [
        arrayExpr(node.elements.map((e) => transformExpr(e, temps, bindings))),
      ]);
    }

    // -- CreateMap ------------------------------------------------------

    case "CreateMap": {
      const hasOptional = node.entries.some((e) => e.optional);
      if (hasOptional) {
        return rtCall("makeMapOptional", [
          arrayExpr(
            node.entries.map((entry) =>
              arrayExpr([
                transformExpr(entry.key, temps, bindings),
                transformExpr(entry.value, temps, bindings),
                literal(entry.optional === true),
              ]),
            ),
          ),
        ]);
      }
      return rtCall("makeMap", [
        arrayExpr(
          node.entries.map((entry) =>
            arrayExpr([
              transformExpr(entry.key, temps, bindings),
              transformExpr(entry.value, temps, bindings),
            ]),
          ),
        ),
      ]);
    }

    // -- CreateStruct ---------------------------------------------------

    case "CreateStruct": {
      const hasOptional = node.entries.some((e) => e.optional);
      if (hasOptional) {
        return rtCall("makeStructOptional", [
          literal(node.messageName),
          arrayExpr(
            node.entries.map((entry) =>
              arrayExpr([
                literal(entry.field),
                transformExpr(entry.value, temps, bindings),
                literal(entry.optional === true),
              ]),
            ),
          ),
        ]);
      }
      return rtCall("makeStruct", [
        literal(node.messageName),
        arrayExpr(
          node.entries.map((entry) =>
            arrayExpr([literal(entry.field), transformExpr(entry.value, temps, bindings)]),
          ),
        ),
      ]);
    }

    // -- Comprehension --------------------------------------------------

    case "Comprehension":
      return transformComprehension(node, temps, bindings);
  }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Flatten a Select chain into a dot-separated qualified name string.
 *  e.g. cel.expr.conformance.proto2.int32_ext -> "cel.expr.conformance.proto2.int32_ext"
 *  Returns undefined if the node is not a pure Select/Ident chain. */
function flattenQualifiedName(node: CelExpr): string | undefined {
  if (node.kind === "Ident") return node.name;
  if (node.kind === "Select" && !node.testOnly) {
    const prefix = flattenQualifiedName(node.operand);
    if (prefix !== undefined) return `${prefix}.${node.field}`;
  }
  return undefined;
}

/** Emit a select chain, using fused helpers for 2-4 hop paths. */
function applySelectChain(base: Expression, fields: readonly string[]): Expression {
  if (fields.length === 0) return base;
  if (fields.length === 1) {
    return rtCall("select", [base, literal(fields[0] as string)]);
  }
  if (fields.length <= 4) {
    return rtCall(`selectPath${fields.length}`, [base, ...fields.map((f) => literal(f))]);
  }

  let result = base;
  for (const field of fields) {
    result = rtCall("select", [result, literal(field)]);
  }
  return result;
}

function typeIs(expr: Expression, typeName: string): Expression {
  return binaryExpr("===", unaryExpr("typeof", expr), literal(typeName));
}

function bothType(left: Expression, right: Expression, typeName: string): Expression {
  return logicalExpr("&&", typeIs(left, typeName), typeIs(right, typeName));
}

function buildPrimitiveBinaryFastPath(
  fn: string,
  args: readonly CelExpr[],
  temps: TempAllocator,
  bindings: Set<string>,
): Expression | undefined {
  if (args.length !== 2) return undefined;

  let fallbackMethod: string | undefined;

  if (fn === "_>_") {
    fallbackMethod = "gt";
  } else if (fn === "_>=_") {
    fallbackMethod = "ge";
  } else if (fn === "_<_") {
    fallbackMethod = "lt";
  } else if (fn === "_<=_") {
    fallbackMethod = "le";
  } else if (fn === "_==_" || fn === "_!=_") {
    fallbackMethod = fn === "_==_" ? "eq" : "ne";
  }

  if (fallbackMethod === undefined) {
    return undefined;
  }

  const left = transformExpr(at(args, 0), temps, bindings);
  const right = transformExpr(at(args, 1), temps, bindings);
  const tmpA = temps.next();
  const tmpB = temps.next();
  const idA = identifier(tmpA);
  const idB = identifier(tmpB);

  let fastExpr: Expression;
  let testExpr: Expression;

  if (fn === "_>_") {
    testExpr = bothType(idA, idB, "bigint");
    fastExpr = binaryExpr(">", idA, idB);
  } else if (fn === "_>=_") {
    testExpr = bothType(idA, idB, "bigint");
    fastExpr = binaryExpr(">=", idA, idB);
  } else if (fn === "_<_") {
    testExpr = bothType(idA, idB, "bigint");
    fastExpr = binaryExpr("<", idA, idB);
  } else if (fn === "_<=_") {
    testExpr = bothType(idA, idB, "bigint");
    fastExpr = binaryExpr("<=", idA, idB);
  } else {
    const stringGuard = bothType(idA, idB, "string");
    const boolGuard = bothType(idA, idB, "boolean");
    const bigintGuard = bothType(idA, idB, "bigint");
    testExpr = logicalExpr("||", stringGuard, logicalExpr("||", boolGuard, bigintGuard));
    fastExpr = binaryExpr(fn === "_==_" ? "===" : "!==", idA, idB);
  }

  return sequenceExpr([
    assignExpr(idA, left),
    assignExpr(idB, right),
    conditional(testExpr, fastExpr, rtCall(fallbackMethod, [idA, idB])),
  ]);
}

function buildStringMethodFastPath(
  rtMethod: "contains" | "startsWith" | "endsWith",
  receiver: Expression,
  arg: Expression,
  temps: TempAllocator,
): Expression {
  const tmpA = temps.next();
  const tmpB = temps.next();
  const idA = identifier(tmpA);
  const idB = identifier(tmpB);
  const jsMethod = rtMethod === "contains" ? "includes" : rtMethod;

  return sequenceExpr([
    assignExpr(idA, receiver),
    assignExpr(idB, arg),
    conditional(
      bothType(idA, idB, "string"),
      callExpr(dot(idA, jsMethod), [idB]),
      rtCall(rtMethod, [idA, idB]),
    ),
  ]);
}

// ---------------------------------------------------------------------------
// Call transformations
// ---------------------------------------------------------------------------

function transformCall(
  fn: string,
  target: CelExpr | undefined,
  args: readonly CelExpr[],
  temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  // -- Logical AND with error absorption --------------------------------
  if (fn === "_&&_" && args.length === 2) {
    return transformLogicalAnd(at(args, 0), at(args, 1), temps, bindings);
  }

  // -- Logical OR with error absorption ---------------------------------
  if (fn === "_||_" && args.length === 2) {
    return transformLogicalOr(at(args, 0), at(args, 1), temps, bindings);
  }

  // -- Logical NOT ------------------------------------------------------
  if (fn === "!_" && args.length === 1) {
    const arg = transformExpr(at(args, 0), temps, bindings);
    // arg === false ? true : arg === true ? false : undefined
    return conditional(
      binaryExpr("===", arg, literal(false)),
      literal(true),
      conditional(binaryExpr("===", arg, literal(true)), literal(false), UNDEF),
    );
  }

  // -- @not_strictly_false (used in comprehension loop conditions) -------
  if (fn === "@not_strictly_false" && args.length === 1) {
    const arg = transformExpr(at(args, 0), temps, bindings);
    // @not_strictly_false(x) = x !== false
    return binaryExpr("!==", arg, literal(false));
  }

  // -- @mapInsert (used in transformMap comprehension step) ---------------
  if (fn === "@mapInsert" && args.length === 3) {
    const map = transformExpr(at(args, 0), temps, bindings);
    const key = transformExpr(at(args, 1), temps, bindings);
    const value = transformExpr(at(args, 2), temps, bindings);
    return rtCall("mapInsert", [map, key, value]);
  }

  // -- Ternary ----------------------------------------------------------
  if (fn === "_?_:_" && args.length === 3) {
    const tmpC = temps.next();
    const idC = identifier(tmpC);
    const cond = transformExpr(at(args, 0), temps, bindings);
    const consequent = transformExpr(at(args, 1), temps, bindings);
    const alternate = transformExpr(at(args, 2), temps, bindings);
    // (_c = cond, _c === true ? consequent : _c === false ? alternate : undefined)
    return sequenceExpr([
      assignExpr(idC, cond),
      conditional(
        binaryExpr("===", idC, literal(true)),
        consequent,
        conditional(binaryExpr("===", idC, literal(false)), alternate, UNDEF),
      ),
    ]);
  }

  const primitiveFastPath = buildPrimitiveBinaryFastPath(fn, args, temps, bindings);
  if (primitiveFastPath !== undefined) {
    return primitiveFastPath;
  }

  // -- Operator functions (arithmetic, comparison, index, in) -----------
  const rtMethod = OPERATOR_TO_RT[fn];
  if (rtMethod !== undefined) {
    const transformedArgs = args.map((a) => transformExpr(a, temps, bindings));
    return rtCall(rtMethod, transformedArgs);
  }

  if (
    target === undefined &&
    args.length === 2 &&
    (fn === "contains" || fn === "startsWith" || fn === "endsWith")
  ) {
    return buildStringMethodFastPath(
      fn,
      transformExpr(at(args, 0), temps, bindings),
      transformExpr(at(args, 1), temps, bindings),
      temps,
    );
  }

  // -- cel.bind(varName, initExpr, bodyExpr) -> IIFE binding -----------
  if (
    fn === "bind" &&
    target !== undefined &&
    target.kind === "Ident" &&
    target.name === "cel" &&
    args.length === 3
  ) {
    const varNameNode = at(args, 0);
    if (varNameNode.kind !== "Ident") {
      throw new Error("cel.bind: first argument must be an identifier");
    }
    const varName = varNameNode.name;
    const initExpr = transformExpr(at(args, 1), temps, bindings);

    // Body uses a local scope: the bound variable should NOT leak to outer bindings
    const innerBindings = new Set(bindings);
    innerBindings.add(varName);
    const bodyExpr = withLocalBindings([varName], () =>
      transformExpr(at(args, 2), temps, innerBindings),
    );

    // Generate: ((varName) => bodyExpr)(initExpr)
    return callExpr(arrowFn([identifier(varName)], bodyExpr, true), [initExpr]);
  }

  // -- cel.block([e0, e1, ...], result) -> IIFE with let declarations ----
  if (
    fn === "block" &&
    target !== undefined &&
    target.kind === "Ident" &&
    target.name === "cel" &&
    args.length === 2
  ) {
    const bindingsNode = at(args, 0);
    if (bindingsNode.kind !== "CreateList") {
      throw new Error("cel.block: first argument must be a list");
    }

    // Use the outer bindings set so external variable references (e.g. msg, x)
    // are properly discovered and passed as parameters to the compiled function.
    // Synthetic names (_bi*, _iv_*) are excluded by isSyntheticName() in the Ident handler.
    const body: Statement[] = [];

    // Declare temp variables needed inside the block IIFE
    const blockTemps = new TempAllocator();

    // Generate let declarations for each binding
    for (let i = 0; i < bindingsNode.elements.length; i++) {
      const bindingExpr = transformExpr(bindingsNode.elements[i] as CelExpr, blockTemps, bindings);
      body.push(varDecl("let", `_bi${i}`, bindingExpr));
    }

    // Transform the result expression
    const resultExpr = transformExpr(at(args, 1), blockTemps, bindings);

    // Add temp variable declarations at the top if any were used
    const blockTempNames = blockTemps.getUsed();
    const tempDecls: Statement[] = [];
    for (const tmp of blockTempNames) {
      tempDecls.push(varDecl("let", tmp, identifier("undefined")));
    }

    // Generate: (() => { let _a; let _bi0 = e0; ...; return result; })()
    return callExpr(
      arrowFn([], blockStatement([...tempDecls, ...body, returnStatement(resultExpr)]), false),
      [],
    );
  }

  // -- proto.hasExt / proto.getExt: flatten qualified name arg to string --
  if (
    target !== undefined &&
    target.kind === "Ident" &&
    target.name === "proto" &&
    (fn === "hasExt" || fn === "getExt") &&
    args.length === 2
  ) {
    const msgArg = transformExpr(at(args, 0), temps, bindings);
    const extNameStr = flattenQualifiedName(at(args, 1));
    if (extNameStr !== undefined) {
      return rtCall(`proto.${fn}`, [msgArg, literal(extNameStr)]);
    }
    // Fallback: evaluate normally
    const extArg = transformExpr(at(args, 1), temps, bindings);
    return rtCall(`proto.${fn}`, [msgArg, extArg]);
  }

  // -- Namespace function call: math.fn(args) -> _rt["math.fn"](args) ---
  if (target !== undefined && target.kind === "Ident" && NAMESPACE_PREFIXES.has(target.name)) {
    const transformedArgs = args.map((a) => transformExpr(a, temps, bindings));
    return rtCall(`${target.name}.${fn}`, transformedArgs);
  }

  // -- Optional member methods: hasValue, value, or, orValue, optMap, optFlatMap
  if (target !== undefined && OPTIONAL_MEMBER_METHODS.has(fn)) {
    const receiver = transformExpr(target, temps, bindings);
    // optMap and optFlatMap: first arg is a variable, second is an expression body
    if ((fn === "optMap" || fn === "optFlatMap") && args.length === 2) {
      const varNode = at(args, 0);
      if (varNode.kind !== "Ident") {
        throw new Error(`${fn}: first argument must be an identifier`);
      }
      const varName = varNode.name;
      const innerBindings = new Set(bindings);
      innerBindings.add(varName);
      const bodyExpr = withLocalBindings([varName], () =>
        transformExpr(at(args, 1), temps, innerBindings),
      );
      const rtName = fn === "optMap" ? "optionalOptMap" : "optionalOptFlatMap";
      return rtCall(rtName, [receiver, arrowFn([identifier(varName)], bodyExpr, true)]);
    }
    const transformedArgs = args.map((a) => transformExpr(a, temps, bindings));
    const rtName = OPTIONAL_MEMBER_TO_RT[fn];
    if (rtName !== undefined) {
      return rtCall(rtName, [receiver, ...transformedArgs]);
    }
  }

  // -- Member method call: obj.method(args) -> _rt.method(obj, ...args) -
  if (target !== undefined) {
    if (args.length === 1 && (fn === "contains" || fn === "startsWith" || fn === "endsWith")) {
      return buildStringMethodFastPath(
        fn,
        transformExpr(target, temps, bindings),
        transformExpr(at(args, 0), temps, bindings),
        temps,
      );
    }
    const receiver = transformExpr(target, temps, bindings);
    const transformedArgs = args.map((a) => transformExpr(a, temps, bindings));
    const memberMethod = MEMBER_FUNC_TO_RT[fn];
    if (memberMethod !== undefined) {
      return rtCall(memberMethod, [receiver, ...transformedArgs]);
    }
    // Unknown member method: route through __dispatch for enum construction
    return rtCall("__dispatch", [literal(fn), arrayExpr([receiver, ...transformedArgs])]);
  }

  // -- Global function call: f(args) -> _rt.f(args) --------------------
  const transformedArgs = args.map((a) => transformExpr(a, temps, bindings));
  const globalMethod = GLOBAL_FUNC_TO_RT[fn];
  if (globalMethod !== undefined) {
    return rtCall(globalMethod, transformedArgs);
  }

  // Fallback: route through __dispatch for enum construction
  return rtCall("__dispatch", [literal(fn), arrayExpr(transformedArgs)]);
}

// ---------------------------------------------------------------------------
// Logical AND/OR with commutative error absorption
// ---------------------------------------------------------------------------

/**
 * CEL logical AND: both sides always evaluated.
 * - If either is false -> false
 * - If either is undefined -> undefined
 * - Otherwise -> true
 *
 * Generated:
 * (_a = left, _b = right,
 *   _a === false ? false :
 *   _b === false ? false :
 *   _a === undefined ? undefined :
 *   _b === undefined ? undefined :
 *   true)
 */
function transformLogicalAnd(
  left: CelExpr,
  right: CelExpr,
  temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  const tmpA = temps.next();
  const tmpB = temps.next();
  const leftExpr = transformExpr(left, temps, bindings);
  const rightExpr = transformExpr(right, temps, bindings);

  const idA = identifier(tmpA);
  const idB = identifier(tmpB);

  return sequenceExpr([
    assignExpr(idA, leftExpr),
    assignExpr(idB, rightExpr),
    conditional(
      binaryExpr("===", idA, literal(false)),
      literal(false),
      conditional(
        binaryExpr("===", idB, literal(false)),
        literal(false),
        conditional(
          logicalExpr(
            "&&",
            binaryExpr("===", idA, literal(true)),
            binaryExpr("===", idB, literal(true)),
          ),
          literal(true),
          UNDEF,
        ),
      ),
    ),
  ]);
}

/**
 * CEL logical OR: both sides always evaluated.
 * - If either is true -> true
 * - If either is undefined -> undefined
 * - Otherwise -> false
 *
 * Generated:
 * (_a = left, _b = right,
 *   _a === true ? true :
 *   _b === true ? true :
 *   _a === undefined ? undefined :
 *   _b === undefined ? undefined :
 *   false)
 */
function transformLogicalOr(
  left: CelExpr,
  right: CelExpr,
  temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  const tmpA = temps.next();
  const tmpB = temps.next();
  const leftExpr = transformExpr(left, temps, bindings);
  const rightExpr = transformExpr(right, temps, bindings);

  const idA = identifier(tmpA);
  const idB = identifier(tmpB);

  return sequenceExpr([
    assignExpr(idA, leftExpr),
    assignExpr(idB, rightExpr),
    conditional(
      binaryExpr("===", idA, literal(true)),
      literal(true),
      conditional(
        binaryExpr("===", idB, literal(true)),
        literal(true),
        conditional(
          logicalExpr(
            "&&",
            binaryExpr("===", idA, literal(false)),
            binaryExpr("===", idB, literal(false)),
          ),
          literal(false),
          UNDEF,
        ),
      ),
    ),
  ]);
}

// ---------------------------------------------------------------------------
// Comprehension
// ---------------------------------------------------------------------------

/**
 * Detect if a comprehension is a simple filter pattern:
 *   list.filter(x, predicate)
 * Pattern: accuInit=[], loopCondition=true, result=accu,
 *   step = test ? accu + [iterVar] : accu
 * Returns the predicate CelExpr if matched, undefined otherwise.
 */
function isFilterPattern(node: CelExpr & { kind: "Comprehension" }): CelExpr | undefined {
  // Must be single-variable comprehension
  if (node.iterVar2 !== undefined) return undefined;

  // accuInit must be empty list
  if (node.accuInit.kind !== "CreateList" || node.accuInit.elements.length !== 0) return undefined;

  // loopCondition must be `true`
  if (node.loopCondition.kind !== "BoolLiteral" || node.loopCondition.value !== true)
    return undefined;

  // result must be the accumulator
  if (node.result.kind !== "Ident" || node.result.name !== node.accuVar) return undefined;

  // loopStep must be _?_:_(test, _+_(accu, [iterVar]), accu)
  const step = node.loopStep;
  if (step.kind !== "Call" || step.fn !== "_?_:_" || step.args.length !== 3) return undefined;

  const [test, consequent, alternate] = step.args;

  // alternate must be Ident(accuVar)
  if (alternate?.kind !== "Ident" || alternate.name !== node.accuVar) return undefined;

  // consequent must be _+_(Ident(accuVar), CreateList([Ident(iterVar)]))
  if (consequent?.kind !== "Call" || consequent.fn !== "_+_" || consequent.args.length !== 2)
    return undefined;

  const [addLhs, addRhs] = consequent.args;
  if (addLhs?.kind !== "Ident" || addLhs.name !== node.accuVar) return undefined;
  if (
    addRhs?.kind !== "CreateList" ||
    addRhs.elements.length !== 1 ||
    addRhs.elements[0]?.kind !== "Ident" ||
    addRhs.elements[0].name !== node.iterVar
  )
    return undefined;

  return test;
}

function transformComprehension(
  node: CelExpr & { kind: "Comprehension" },
  temps: TempAllocator,
  bindings: Set<string>,
): Expression {
  // Fast path: detect simple filter pattern and emit _rt.filterList()
  const filterPredicate = isFilterPattern(node);
  if (filterPredicate !== undefined) {
    const iterRange = transformExpr(node.iterRange, temps, bindings);
    const innerBindings = new Set(bindings);
    innerBindings.add(node.iterVar);
    const predBody = withLocalBindings([node.iterVar], () =>
      transformExpr(filterPredicate, temps, innerBindings),
    );
    return rtCall("filterList", [iterRange, arrowFn([identifier(node.iterVar)], predBody, true)]);
  }

  const iterRange = transformExpr(node.iterRange, temps, bindings);
  const accuInit = transformExpr(node.accuInit, temps, bindings);

  // Comprehension-local vars should not leak to outer bindings.
  // Use a separate set that inherits from the outer one.
  const innerBindings = new Set(bindings);
  innerBindings.add(node.iterVar);
  innerBindings.add(node.accuVar);
  if (node.iterVar2 !== undefined) {
    innerBindings.add(node.iterVar2);
  }

  const localNames =
    node.iterVar2 !== undefined
      ? [node.iterVar, node.accuVar, node.iterVar2]
      : [node.iterVar, node.accuVar];
  const loopCondition = withLocalBindings(localNames, () =>
    transformExpr(node.loopCondition, temps, innerBindings),
  );
  const loopStep = withLocalBindings(localNames, () =>
    transformExpr(node.loopStep, temps, innerBindings),
  );
  const result = withLocalBindings([node.accuVar], () =>
    transformExpr(node.result, temps, innerBindings),
  );

  // Build lambda parameters: (iterVar [, iterVar2], accuVar)
  const condParams =
    node.iterVar2 !== undefined
      ? [identifier(node.iterVar), identifier(node.iterVar2), identifier(node.accuVar)]
      : [identifier(node.iterVar), identifier(node.accuVar)];
  const stepParams = [...condParams]; // same params for step
  const resultParams = [identifier(node.accuVar)];

  const args: Expression[] = [
    iterRange,
    accuInit,
    literal(node.iterVar),
    literal(node.accuVar),
    arrowFn(condParams, loopCondition, true),
    arrowFn(stepParams, loopStep, true),
    arrowFn(resultParams, result, true),
  ];

  // Pass iterVar2 name if present (two-variable comprehension)
  if (node.iterVar2 !== undefined) {
    args.push(literal(node.iterVar2));
  }

  return rtCall("comprehension", args);
}
